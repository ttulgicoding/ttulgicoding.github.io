<!DOCTYPE html><html lang="ko"><head><meta charSet="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><meta property="og:site_name" content="뚤기코딩의 블로그"/><meta property="og:title" content="test - 뚤기코딩의 블로그"/><meta property="og:type" content="website"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:url" content="/%EC%9E%90%EA%B2%A9%EC%A6%9D/test5"/><meta property="og:locale" content="ko_KR"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@undefined"/><meta name="twitter:creator" content="@undefined"/><meta name="twitter:title" content="test - 뚤기코딩의 블로그"/><meta name="twitter:description" content=""/><meta name="twitter:image" content=""/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="generator" content="MS Visual Studio Code"/><meta name="author"/><link rel="canonical" href="/%EC%9E%90%EA%B2%A9%EC%A6%9D/test5"/><title>test - 뚤기코딩의 블로그</title><meta name="next-head-count" content="22"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"/><link rel="preload" href="/_next/static/css/8803b53e53aeca9c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8803b53e53aeca9c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2523469b12db673d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2523469b12db673d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-2f7c9761d58c33d5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7694026f64d604c2.js" defer=""></script><script src="/_next/static/chunks/61-23de333b5c8f7178.js" defer=""></script><script src="/_next/static/chunks/pages/%5BmCategory%5D/%5BpostSlug%5D-3fd85c62b1c9aabc.js" defer=""></script><script src="/_next/static/TyfEYxo7SEQWKygUyTv8U/_buildManifest.js" defer=""></script><script src="/_next/static/TyfEYxo7SEQWKygUyTv8U/_ssgManifest.js" defer=""></script></head><body><div id="__next"><aside><div class="Aside_Aside_container__Pw_YZ"><div class="Aside_Aside_Scroll__yzUkh"><section class="Profile_profile__g_l40"><div class="Profile_image__4E_gs"><img alt="뚤기" loading="lazy" width="150" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/blog/노말뚤기.png"/></div><p class="Profile_emp___Egcn">뚤기코딩</p><p style="margin:10px 0 0 0">프로필</p></section><nav class="MainNavigation_category_section__mh5Wk"><a class="MainNavigation_home_tag__CZWg1" href="/">홈</a><ul class="MainNavigation_main_category__Enh1I"><a href="/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><li class="Category_li__kvLT5">프로그래밍<span>▶</span></li></a><a href="/%EC%9E%90%EA%B2%A9%EC%A6%9D"><li class="Category_li__kvLT5">자격증<span>▶</span></li></a><a href="/%EC%B1%85"><li class="Category_li__kvLT5">책<span>▶</span></li></a><a href="/%EC%B7%A8%EB%AF%B8"><li class="Category_li__kvLT5">취미<span>▶</span></li></a></ul></nav></div></div></aside><main class="Main_main__pMVvP"><h1 style="margin-bottom:50px">[test]test5</h1><div style="margin:0 auto;width:60%;text-align:left;margin-bottom:50px"><span class="PostTag_tag__LBMEE ">테스트</span><span class="PostTag_tag__LBMEE ">실기</span></div><div style="text-align:left;width:60%;margin:0 auto"><span style="background-color:#000;border-radius:10%;color:#fff;padding:0.4rem;font-size:1.2rem;font-weight:900">정보처리기사</span>
<br/>
<br/>
<h2><strong>관계대수는</strong></h2>
<br/>
<ul>
<li>관계형 데이터베이스에서 원하는 정보와 그 정보를 얻기 위해 어떻게 해야하는 가를 명세하는 절차적인 언어이다.<!-- -->
<br/>
<br/>
</li>
<li>관계대수를 통해 릴레이션을 원하는 <a href="#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98"><strong>릴레이션</strong></a>으로 연산 도출할 수 있다.      <br/><br/></li>
<li>관계대수에는 순수 관계 연산자와 일반 집합 연산자가 있다.<!-- -->
<br/>
<br/>
</li>
</ul>
<br/>
<hr/>
<br/>
<h2><strong>순수 관계 연산자</strong></h2>
<br/>
<ul>
<li>
<h3>Select</h3>
<ul>
<li><strong>Select</strong> 연산자는 <strong>σ</strong> <strong>(sigma)</strong>로 표현한다.</li>
<li>원하는 <a href="#%ED%8A%9C%ED%94%8C"><strong>튜플</strong></a>을 출력한다.</li>
<li><strong>ex)</strong> σNUMBER = 3(USER)에서 USER는 테이블이 되고 NUMBER은 <a href="#%EC%86%8D%EC%84%B1"><strong>속성</strong></a>(Attribute)이 된다.<br/>
즉, USER테이블의 NUMBER가 3인 튜플들을 출력하게 된다.</li>
</ul>
</li>
</ul>
<br/>
<br/>
<ul>
<li>
<h3>Project</h3>
<ul>
<li><strong>Project</strong> 연산자는 <strong>π</strong> <strong>(pi)</strong>로 표현한다.</li>
<li>원하는 <a href="#%EC%86%8D%EC%84%B1"><strong>속성</strong></a>(Attribute)을 표현한다.</li>
<li>Select 연산으로는 <a href="#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98"><strong>릴레이션</strong></a>에 중복 <a href="#%ED%8A%9C%ED%94%8C"><strong>튜플</strong></a>이 존재하지 않으나, Project 연산에서는 중복된 <a href="#%ED%8A%9C%ED%94%8C"><strong>튜플</strong></a>이 나올 수 있으나 자동으로 중복을 제거한 후 결과를 도출한다.</li>
<li><strong>ex)</strong> πNUMBER(USER)의 경우에는 USER 테이블의 NUMBER 속성을 중복을 제거하고 전부 도출한다.</li>
</ul>
</li>
</ul>
<br/>
<br/>
<ul>
<li>
<h3>Join</h3>
<p style="font-size:3rem">테스트 글입니다.</p>
</li>
</ul>
<img src="/images/blog/둘기.gif" alt="테스트 이미지"/></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"frontMatter":{"dirName":"certificate","contentNo":5,"mainCategory":"자격증","tag":["테스트","실기"],"title":"[test]test5","updated":"2023-04-23","image":"프로그래밍.png","isFeatured":true},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"span\", {\n      style: {\n        backgroundColor: \"#000\",\n        borderRadius: '10%',\n        color: '#fff',\n        padding: '0.4rem',\n        fontSize: \"1.2rem\",\n        fontWeight: \"900\"\n      },\n      children: \"정보처리기사\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"h2\", {\n      children: _jsx(\"strong\", {\n        children: \"관계대수는\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"관계형 데이터베이스에서 원하는 정보와 그 정보를 얻기 위해 어떻게 해야하는 가를 명세하는 절차적인 언어이다.\", \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"관계대수를 통해 릴레이션을 원하는 \", _jsx(_components.a, {\n          href: \"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98\",\n          children: _jsx(_components.strong, {\n            children: \"릴레이션\"\n          })\n        }), \"으로 연산 도출할 수 있다.      \", _jsx(\"br\", {}), _jsx(\"br\", {})]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"관계대수에는 순수 관계 연산자와 일반 집합 연산자가 있다.\", \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"hr\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"h2\", {\n      children: _jsx(\"strong\", {\n        children: \"순수 관계 연산자\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Select\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"Select\"\n            }), \" 연산자는 \", _jsx(\"strong\", {\n              children: \"σ\"\n            }), \" \", _jsx(\"strong\", {\n              children: \"(sigma)\"\n            }), \"로 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"원하는 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"을 출력한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"ex)\"\n            }), \" σNUMBER = 3(USER)에서 USER는 테이블이 되고 NUMBER은 \", _jsx(_components.a, {\n              href: \"#%EC%86%8D%EC%84%B1\",\n              children: _jsx(_components.strong, {\n                children: \"속성\"\n              })\n            }), \"(Attribute)이 된다.\", _jsx(\"br\", {}), \"\\r\\n즉, USER테이블의 NUMBER가 3인 튜플들을 출력하게 된다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Project\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"Project\"\n            }), \" 연산자는 \", _jsx(\"strong\", {\n              children: \"π\"\n            }), \" \", _jsx(\"strong\", {\n              children: \"(pi)\"\n            }), \"로 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"원하는 \", _jsx(_components.a, {\n              href: \"#%EC%86%8D%EC%84%B1\",\n              children: _jsx(_components.strong, {\n                children: \"속성\"\n              })\n            }), \"(Attribute)을 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Select 연산으로는 \", _jsx(_components.a, {\n              href: \"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98\",\n              children: _jsx(_components.strong, {\n                children: \"릴레이션\"\n              })\n            }), \"에 중복 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"이 존재하지 않으나, Project 연산에서는 중복된 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"이 나올 수 있으나 자동으로 중복을 제거한 후 결과를 도출한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"ex)\"\n            }), \" πNUMBER(USER)의 경우에는 USER 테이블의 NUMBER 속성을 중복을 제거하고 전부 도출한다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Join\"\n        }), \"\\n\", _jsx(\"p\", {\n          style: {\n            fontSize: \"3rem\"\n          },\n          children: \"테스트 글입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/blog/둘기.gif\",\n      alt: \"테스트 이미지\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"slug":"test5"}},"__N_SSG":true},"page":"/[mCategory]/[postSlug]","query":{"mCategory":"자격증","postSlug":"test5"},"buildId":"TyfEYxo7SEQWKygUyTv8U","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>