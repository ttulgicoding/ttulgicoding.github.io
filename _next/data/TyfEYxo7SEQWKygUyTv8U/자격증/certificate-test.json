{"pageProps":{"post":{"frontMatter":{"dirName":"certificate","contentNo":1,"mainCategory":"자격증","tag":["정보처리기사","실기"],"title":"[정보처리기사]관계대수 및 순수 관계 연산자","updated":"2023-04-22","image":"프로그래밍.png","isFeatured":true},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"h2\", {\n      children: _jsx(\"strong\", {\n        children: \"관계대수는\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"관계형 데이터베이스에서 원하는 정보와 그 정보를 얻기 위해 어떻게 해야하는 가를 명세하는 절차적인 언어이다.\", \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"관계대수를 통해 릴레이션을 원하는 \", _jsx(_components.a, {\n          href: \"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98\",\n          children: _jsx(_components.strong, {\n            children: \"릴레이션\"\n          })\n        }), \"으로 연산 도출할 수 있다.      \", _jsx(\"br\", {}), _jsx(\"br\", {})]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"관계대수에는 순수 관계 연산자와 일반 집합 연산자가 있다.\", \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"hr\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"h2\", {\n      children: _jsx(\"strong\", {\n        children: \"순수 관계 연산자\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Select\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"Select\"\n            }), \" 연산자는 \", _jsx(\"strong\", {\n              children: \"σ\"\n            }), \" \", _jsx(\"strong\", {\n              children: \"(sigma)\"\n            }), \"로 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"원하는 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"을 출력한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"ex)\"\n            }), \" σNUMBER = 3(USER)에서 USER는 테이블이 되고 NUMBER은 \", _jsx(_components.a, {\n              href: \"#%EC%86%8D%EC%84%B1\",\n              children: _jsx(_components.strong, {\n                children: \"속성\"\n              })\n            }), \"(Attribute)이 된다.\", _jsx(\"br\", {}), \"\\r\\n즉, USER테이블의 NUMBER가 3인 튜플들을 출력하게 된다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Project\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"Project\"\n            }), \" 연산자는 \", _jsx(\"strong\", {\n              children: \"π\"\n            }), \" \", _jsx(\"strong\", {\n              children: \"(pi)\"\n            }), \"로 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"원하는 \", _jsx(_components.a, {\n              href: \"#%EC%86%8D%EC%84%B1\",\n              children: _jsx(_components.strong, {\n                children: \"속성\"\n              })\n            }), \"(Attribute)을 표현한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Select 연산으로는 \", _jsx(_components.a, {\n              href: \"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98\",\n              children: _jsx(_components.strong, {\n                children: \"릴레이션\"\n              })\n            }), \"에 중복 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"이 존재하지 않으나, Project 연산에서는 중복된 \", _jsx(_components.a, {\n              href: \"#%ED%8A%9C%ED%94%8C\",\n              children: _jsx(_components.strong, {\n                children: \"튜플\"\n              })\n            }), \"이 나올 수 있으나 자동으로 중복을 제거한 후 결과를 도출한다.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(\"strong\", {\n              children: \"ex)\"\n            }), \" πNUMBER(USER)의 경우에는 USER 테이블의 NUMBER 속성을 중복을 제거하고 전부 도출한다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"h3\", {\n          children: \"Join\"\n        }), \"\\n\", _jsx(\"p\", {\n          style: {\n            fontSize: \"3rem\"\n          },\n          children: \"테스트 글입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/blog/둘기.gif\",\n      alt: \"테스트 이미지\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"slug":"certificate-test"}},"__N_SSG":true}